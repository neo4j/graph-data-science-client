[
  {
    "function": {
      "name": "gds.allShortestPaths.delta.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Delta Stepping shortest path algorithm computes the shortest (weighted) path\nbetween one node and any other node in the graph. The computation is run multi-threaded."
  },
  {
    "function": {
      "name": "gds.allShortestPaths.delta.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for allShortestPaths.dealta.mutate."
  },
  {
    "function": {
      "name": "gds.allShortestPaths.delta.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Delta Stepping shortest path algorithm computes the shortest (weighted) path\nbetween one node and any other node in the graph. The computation is run multi-threaded"
  },
  {
    "function": {
      "name": "gds.allShortestPaths.delta.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for allShortestPaths.delta.stats."
  },
  {
    "function": {
      "name": "gds.allShortestPaths.delta.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The Delta Stepping shortest path algorithm computes the shortest (weighted) path\nbetween one node and any other node in the graph. The computation is run multi-threaded."
  },
  {
    "function": {
      "name": "gds.allShortestPaths.delta.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for allShortestPaths.delta.strema."
  },
  {
    "function": {
      "name": "gds.allShortestPaths.delta.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Delta Stepping shortest path algorithm computes the shortest (weighted) path\nbetween one node and any other node in the graph. The computation is run multi-threaded."
  },
  {
    "function": {
      "name": "gds.allShortestPaths.delta.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.allShortestPaths.dijkstra.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Dijkstra shortest path algorithm computes the shortest (weighted) path\nbetween one node and any other node in the graph."
  },
  {
    "function": {
      "name": "gds.allShortestPaths.dijkstra.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.allShortestPaths.dijkstra.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The Dijkstra shortest path algorithm computes the shortest (weighted) path\nbetween one node and any other node in the graph."
  },
  {
    "function": {
      "name": "gds.allShortestPaths.dijkstra.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.allShortestPaths.dijkstra.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Dijkstra shortest path algorithm computes the shortest (weighted) path\nbetween one node and any other node in the graph."
  },
  {
    "function": {
      "name": "gds.allShortestPaths.dijkstra.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.allShortestPaths.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The All Pairs Shortest Path (APSP) calculates the shortest (weighted) path\nbetween all pairs of nodes."
  },
  {
    "function": {
      "name": "gds.allShortestPaths.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.alpha.allShortestPaths.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The All Pairs Shortest Path (APSP) calculates the shortest (weighted) path\nbetween all pairs of nodes.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.allShortestPaths.stream` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.closeness.harmonic.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Harmonic centrality is a way of detecting nodes that are able to spread information\nvery efficiently through a graph.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.closeness.harmonic.stream` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.closeness.harmonic.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Harmonic centrality is a way of detecting nodes that are able to spread information\nvery efficiently through a graph.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.closeness.harmonic.write` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.conductance.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Evaluates a division of nodes into communities based on the proportion of relationships\nthat cross community boundaries."
  },
  {
    "function": {
      "name": "gds.alpha.graph.sample.rwr",
      "signature": "graph_name: str, from_G: Graph, **config: Any",
      "return_type": "GraphCreateResult"
    },
    "description": "Constructs a random subgraph based on random walks with restarts.",
    "deprecated": {
      "version": "2.4.0",
      "message": "Since GDS server version 2.4.0 you should use the endpoint :func:`gds.graph.sample.rwr` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.hits.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.hits.mutate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.hits.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.hits.mutate.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.hits.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.hits.stats` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.hits.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.hits.stats.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.hits.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.hits.stream` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.hits.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.hits.stream.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.hits.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.hits.write` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.hits.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.hits.write.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.kSpanningTree.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The K-spanning tree algorithm starts from a root node and returns a spanning tree with exactly k nodes",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.kSpanningTree.write` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.knn.filtered.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties.\nFiltered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively."
  },
  {
    "function": {
      "name": "gds.alpha.knn.filtered.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties.\nFiltered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively."
  },
  {
    "function": {
      "name": "gds.alpha.knn.filtered.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties.\nFiltered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively."
  },
  {
    "function": {
      "name": "gds.alpha.knn.filtered.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties.\nFiltered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively."
  },
  {
    "function": {
      "name": "gds.alpha.maxkcut.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Approximate Maximum k-cut maps each node into one of k disjoint communities\ntrying to maximize the sum of weights of relationships between these communities."
  },
  {
    "function": {
      "name": "gds.alpha.maxkcut.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Approximate Maximum k-cut maps each node into one of k disjoint communities\ntrying to maximize the sum of weights of relationships between these communities."
  },
  {
    "function": {
      "name": "gds.alpha.maxkcut.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Approximate Maximum k-cut maps each node into one of k disjoint communities\ntrying to maximize the sum of weights of relationships between these communities."
  },
  {
    "function": {
      "name": "gds.alpha.maxkcut.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Approximate Maximum k-cut maps each node into one of k disjoint communities\ntrying to maximize the sum of weights of relationships between these communities."
  },
  {
    "function": {
      "name": "gds.alpha.modularity.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    }
  },
  {
    "function": {
      "name": "gds.alpha.modularity.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    }
  },
  {
    "function": {
      "name": "gds.alpha.nodeSimilarity.filtered.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nThe algorithm computes pair-wise similarities based on Jaccard or Overlap metrics.\nThe filtered variant supports limiting which nodes to compare via source and target node filters."
  },
  {
    "function": {
      "name": "gds.alpha.nodeSimilarity.filtered.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.alpha.nodeSimilarity.filtered.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nThe algorithm computes pair-wise similarities based on Jaccard or Overlap metrics.\nThe filtered variant supports limiting which nodes to compare via source and target node filters."
  },
  {
    "function": {
      "name": "gds.alpha.nodeSimilarity.filtered.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.alpha.nodeSimilarity.filtered.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nThe algorithm computes pair-wise similarities based on Jaccard or Overlap metrics.\nThe filtered variant supports limiting which nodes to compare via source and target node filters."
  },
  {
    "function": {
      "name": "gds.alpha.nodeSimilarity.filtered.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.alpha.nodeSimilarity.filtered.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nThe algorithm computes pair-wise similarities based on Jaccard or Overlap metrics.\nThe filtered variant supports limiting which nodes to compare via source and target node filters."
  },
  {
    "function": {
      "name": "gds.alpha.nodeSimilarity.filtered.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.alpha.scaleProperties.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Scale node properties",
    "deprecated": {
      "version": "2.4.0",
      "message": "Since GDS server version 2.4.0 you should use the endpoint :func:`gds.scaleProperties.mutate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.scaleProperties.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Scale node properties",
    "deprecated": {
      "version": "2.4.0",
      "message": "Since GDS server version 2.4.0 you should use the endpoint :func:`gds.scaleProperties.stream` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.scc.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The SCC algorithm finds sets of connected nodes in an directed graph,\nwhere all nodes in the same set form a connected component."
  },
  {
    "function": {
      "name": "gds.alpha.scc.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The SCC algorithm finds sets of connected nodes in an directed graph,\nwhere all nodes in the same set form a connected component."
  },
  {
    "function": {
      "name": "gds.alpha.sllpa.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.sllpa.mutate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.sllpa.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.sllpa.mutate.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.sllpa.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.sllpa.stats` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.sllpa.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.sllpa.stats.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.sllpa.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.sllpa.stream` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.sllpa.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.sllpa.stream.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.sllpa.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.sllpa.write` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.sllpa.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.sllpa.write.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.triangles",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Triangles streams the nodeIds of each triangle in the graph.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.triangles` instead."
    }
  },
  {
    "function": {
      "name": "gds.articleRank.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Article Rank is a variant of the Page Rank algorithm, which measures the transitive influence or connectivity of nodes."
  },
  {
    "function": {
      "name": "gds.articleRank.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.articleRank.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Executes the algorithm and returns result statistics without writing the result to Neo4j."
  },
  {
    "function": {
      "name": "gds.articleRank.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.articleRank.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Article Rank is a variant of the Page Rank algorithm, which measures the transitive influence or connectivity of nodes."
  },
  {
    "function": {
      "name": "gds.articleRank.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.articleRank.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Article Rank is a variant of the Page Rank algorithm, which measures the transitive influence or connectivity of nodes."
  },
  {
    "function": {
      "name": "gds.articleRank.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.articulationPoints.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Articulation Points is an algorithm that finds nodes that disconnect components if removed."
  },
  {
    "function": {
      "name": "gds.articulationPoints.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },

  {
    "function": {
      "name": "gds.articulationPoints.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Articulation Points is an algorithm that finds nodes that disconnect components if removed."
  },
  {
    "function": {
      "name": "gds.articulationPoints.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.articulationPoints.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Articulation Points is an algorithm that finds nodes that disconnect components if removed."
  },
  {
    "function": {
      "name": "gds.articulationPoints.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.articulationPoints.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Articulation Points is an algorithm that finds nodes that disconnect components if removed."
  },
  {
    "function": {
      "name": "gds.articulationPoints.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.bellmanFord.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Bellman-Ford shortest path algorithm computes the shortest (weighted) path between one node\nand any other node in the graph without negative cycles."
  },
  {
    "function": {
      "name": "gds.bellmanFord.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.bellmanFord.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Bellman-Ford shortest path algorithm computes the shortest (weighted) path between one node\nand any other node in the graph without negative cycles."
  },
  {
    "function": {
      "name": "gds.bellmanFord.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.bellmanFord.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The Bellman-Ford shortest path algorithm computes the shortest (weighted) path between one node\nand any other node in the graph without negative cycles."
  },
  {
    "function": {
      "name": "gds.bellmanFord.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.bellmanFord.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Bellman-Ford shortest path algorithm computes the shortest (weighted) path between one node\nand any other node in the graph without negative cycles."
  },
  {
    "function": {
      "name": "gds.bellmanFord.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.beta.closeness.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph."
  },
  {
    "function": {
      "name": "gds.beta.closeness.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph."
  },
  {
    "function": {
      "name": "gds.beta.closeness.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph."
  },
  {
    "function": {
      "name": "gds.beta.closeness.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph."
  },
  {
    "function": {
      "name": "gds.beta.collapsePath.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Collapse Path algorithm is a traversal algorithm capable of creating relationships between the start\nand end nodes of a traversal"
  },
  {
    "function": {
      "name": "gds.beta.influenceMaximization.celf.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes\nthat maximize the expected spread of influence in the network."
  },
  {
    "function": {
      "name": "gds.beta.influenceMaximization.celf.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.beta.influenceMaximization.celf.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Executes the algorithm and returns result statistics without writing the result to Neo4j."
  },
  {
    "function": {
      "name": "gds.beta.influenceMaximization.celf.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.beta.influenceMaximization.celf.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes\nthat maximize the expected spread of influence in the network."
  },
  {
    "function": {
      "name": "gds.beta.influenceMaximization.celf.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes\nthat maximize the expected spread of influence in the network."
  },
  {
    "function": {
      "name": "gds.beta.influenceMaximization.celf.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes\nthat maximize the expected spread of influence in the network."
  },
  {
    "function": {
      "name": "gds.beta.influenceMaximization.celf.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.beta.k1coloring.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The K-1 Coloring algorithm assigns a color to every node in the graph."
  },
  {
    "function": {
      "name": "gds.beta.k1coloring.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.beta.k1coloring.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The K-1 Coloring algorithm assigns a color to every node in the graph."
  },
  {
    "function": {
      "name": "gds.beta.k1coloring.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.beta.k1coloring.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The K-1 Coloring algorithm assigns a color to every node in the graph."
  },
  {
    "function": {
      "name": "gds.beta.k1coloring.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.beta.k1coloring.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The K-1 Coloring algorithm assigns a color to every node in the graph."
  },
  {
    "function": {
      "name": "gds.beta.k1coloring.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.beta.kmeans.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Kmeans  algorithm clusters nodes into different communities based on Euclidean distance",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.kmeans.mutate` instead."
    }
  },
  {
    "function": {
      "name": "gds.beta.kmeans.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.kmeans.mutate.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.beta.kmeans.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Kmeans  algorithm clusters nodes into different communities based on Euclidean distance",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.kmeans.stats` instead."
    }
  },
  {
    "function": {
      "name": "gds.beta.kmeans.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.kmeans.stats.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.beta.kmeans.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The Kmeans  algorithm clusters nodes into different communities based on Euclidean distance",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.kmeans.stream` instead."
    }
  },
  {
    "function": {
      "name": "gds.beta.kmeans.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.kmeans.stream.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.beta.kmeans.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Kmeans  algorithm clusters nodes into different communities based on Euclidean distance",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.kmeans.write` instead."
    }
  },
  {
    "function": {
      "name": "gds.beta.kmeans.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.kmeans.write.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.beta.leiden.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Leiden is a community detection algorithm, which guarantees that communities are well connected"
  },
  {
    "function": {
      "name": "gds.beta.leiden.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.beta.leiden.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Executes the algorithm and returns result statistics without writing the result to Neo4j."
  },
  {
    "function": {
      "name": "gds.beta.leiden.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.beta.leiden.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Leiden is a community detection algorithm, which guarantees that communities are well connected"
  },
  {
    "function": {
      "name": "gds.beta.leiden.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.beta.leiden.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Leiden is a community detection algorithm, which guarantees that communities are well connected"
  },
  {
    "function": {
      "name": "gds.beta.leiden.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.beta.modularityOptimization.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity."
  },
  {
    "function": {
      "name": "gds.beta.modularityOptimization.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.beta.modularityOptimization.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity."
  },
  {
    "function": {
      "name": "gds.beta.modularityOptimization.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.beta.modularityOptimization.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity."
  },
  {
    "function": {
      "name": "gds.beta.modularityOptimization.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.cliqueCounting.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Counts the number of cliques, of different size, each node is part of."
  },
  {
    "function": {
      "name": "gds.cliqueCounting.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.cliqueCounting.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Counts the number of cliques, of different size, each node is part of."
  },
  {
    "function": {
      "name": "gds.cliqueCounting.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.cliqueCounting.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Counts the number of cliques, of different size, in the entire graph."
  },
  {
    "function": {
      "name": "gds.cliqueCounting.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.cliqueCounting.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Counts the number of cliques, of different size, each node is part of."
  },
  {
    "function": {
      "name": "gds.cliqueCounting.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.scaleProperties.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Scale node properties"
  },
  {
    "function": {
      "name": "gds.scaleProperties.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.scaleProperties.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Scale node properties"
  },
  {
    "function": {
      "name": "gds.scaleProperties.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.scaleProperties.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Scale node properties"
  },
  {
    "function": {
      "name": "gds.scaleProperties.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.scaleProperties.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Scale node properties"
  },
  {
    "function": {
      "name": "gds.scaleProperties.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.scc.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component."
  },
  {
    "function": {
      "name": "gds.scc.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for SCC."
  },
  {
    "function": {
      "name": "gds.scc.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component."
  },
  {
    "function": {
      "name": "gds.scc.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for SCC."
  },
  {
    "function": {
      "name": "gds.scc.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component."
  },
  {
    "function": {
      "name": "gds.scc.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for SCC."
  },
  {
    "function": {
      "name": "gds.scc.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component."
  },
  {
    "function": {
      "name": "gds.scc.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for SCC."
  },
  {
    "function": {
      "name": "gds.beta.spanningTree.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The spanning tree algorithm visits all nodes that are in the same connected component as the starting node,\nand returns a spanning tree of all nodes in the component where the total weight of the relationships is either minimized or maximized."
  },
  {
    "function": {
      "name": "gds.beta.spanningTree.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.beta.spanningTree.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The spanning tree algorithm visits all nodes that are in the same connected component as the starting node,\nand returns a spanning tree of all nodes in the component\nwhere the total weight of the relationships is either minimized or maximized."
  },
  {
    "function": {
      "name": "gds.beta.spanningTree.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.beta.spanningTree.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The spanning tree algorithm visits all nodes that are in the same connected component as the starting node,\nand returns a spanning tree of all nodes in the component\nwhere the total weight of the relationships is either minimized or maximized."
  },
  {
    "function": {
      "name": "gds.beta.spanningTree.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.beta.spanningTree.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The spanning tree algorithm visits all nodes that are in the same connected component as the starting node,\nand returns a spanning tree of all nodes in the component\nwhere the total weight of the relationships is either minimized or maximized."
  },
  {
    "function": {
      "name": "gds.beta.spanningTree.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.beta.steinerTree.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The steiner tree algorithm accepts a source node, as well as a list of target nodes.\nIt then attempts to find a spanning tree where there is a path from the source node to each target node,\nsuch that the total weight of the relationships is as low as possible."
  },
  {
    "function": {
      "name": "gds.beta.steinerTree.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The steiner tree algorithm accepts a source node, as well as a list of target nodes.\nIt then attempts to find a spanning tree where there is a path from the source node to each target node,\nsuch that the total weight of the relationships is as low as possible."
  },
  {
    "function": {
      "name": "gds.beta.steinerTree.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The steiner tree algorithm accepts a source node, as well as a list of target nodes.\nIt then attempts to find a spanning tree where there is a path from the source node to each target node,\nsuch that the total weight of the relationships is as low as possible."
  },
  {
    "function": {
      "name": "gds.beta.steinerTree.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The steiner tree algorithm accepts a source node, as well as a list of target nodes.\nIt then attempts to find a spanning tree where there is a path from the source node to each target node,\nsuch that the total weight of the relationships is as low as possible."
  },
  {
    "function": {
      "name": "gds.betweenness.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Betweenness centrality measures the relative information flow that passes through a node."
  },
  {
    "function": {
      "name": "gds.betweenness.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Betweenness centrality measures the relative information flow that passes through a node."
  },
  {
    "function": {
      "name": "gds.betweenness.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Betweenness centrality measures the relative information flow that passes through a node."
  },
  {
    "function": {
      "name": "gds.betweenness.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Betweenness centrality measures the relative information flow that passes through a node."
  },
  {
    "function": {
      "name": "gds.betweenness.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Betweenness centrality measures the relative information flow that passes through a node."
  },
  {
    "function": {
      "name": "gds.betweenness.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Betweenness centrality measures the relative information flow that passes through a node."
  },
  {
    "function": {
      "name": "gds.betweenness.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Betweenness centrality measures the relative information flow that passes through a node."
  },
  {
    "function": {
      "name": "gds.betweenness.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Betweenness centrality measures the relative information flow that passes through a node."
  },
  {
    "function": {
      "name": "gds.bfs.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "BFS is a traversal algorithm, which explores all of the neighbor nodes at the present depth\nprior to moving on to the nodes at the next depth level."
  },
  {
    "function": {
      "name": "gds.bfs.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.bfs.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "BFS is a traversal algorithm, which explores all of the neighbor nodes at the present depth\nprior to moving on to the nodes at the next depth level."
  },
  {
    "function": {
      "name": "gds.bfs.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.bfs.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "BFS is a traversal algorithm, which explores all of the neighbor nodes at the present depth\nprior to moving on to the nodes at the next depth level."
  },
  {
    "function": {
      "name": "gds.bfs.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "BFS is a traversal algorithm, which explores all of the neighbor nodes at the present depth\nprior to moving on to the nodes at the next depth level."
  },
  {
    "function": {
      "name": "gds.bridges.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "An algorithm to find Bridge edges in a graph."
  },
  {
    "function": {
      "name": "gds.bridges.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.closeness.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph."
  },
  {
    "function": {
      "name": "gds.closeness.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.closeness.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph."
  },
  {
    "function": {
      "name": "gds.closeness.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.closeness.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph."
  },
  {
    "function": {
      "name": "gds.closeness.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.closeness.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph."
  },
  {
    "function": {
      "name": "gds.closeness.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.closeness.harmonic.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Harmonic centrality is a way of detecting nodes that are able to spread information\nvery efficiently through a graph."
  },
  {
    "function": {
      "name": "gds.closeness.harmonic.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.closeness.harmonic.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Harmonic centrality is a way of detecting nodes that are able to spread information\nvery efficiently through a graph."
  },
  {
    "function": {
      "name": "gds.closeness.harmonic.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.closeness.harmonic.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Harmonic centrality is a way of detecting nodes that are able to spread information\nvery efficiently through a graph."
  },
  {
    "function": {
      "name": "gds.closeness.harmonic.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.closeness.harmonic.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Harmonic centrality is a way of detecting nodes that are able to spread information\nvery efficiently through a graph."
  },
  {
    "function": {
      "name": "gds.closeness.harmonic.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.collapsePath.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Collapse Path algorithm is a traversal algorithm capable of creating relationships between the start\nand end nodes of a traversal"
  },
  {
    "function": {
      "name": "gds.conductance.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Evaluates a division of nodes into communities based on the proportion of relationships\nthat cross community boundaries."
  },
  {
    "function": {
      "name": "gds.dag.topologicalSort.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Returns a topological ordering of the nodes in a directed acyclic graph (DAG)."
  },
  {
    "function": {
      "name": "gds.dag.longestPath.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Finds the longest path that leads to a node in a directed acyclic graph (DAG)."
  },
  {
    "function": {
      "name": "gds.degree.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Degree centrality measures the number of incoming and outgoing relationships from a node."
  },
  {
    "function": {
      "name": "gds.degree.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Degree centrality measures the number of incoming and outgoing relationships from a node."
  },
  {
    "function": {
      "name": "gds.degree.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Degree centrality measures the number of incoming and outgoing relationships from a node."
  },
  {
    "function": {
      "name": "gds.degree.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Degree centrality measures the number of incoming and outgoing relationships from a node."
  },
  {
    "function": {
      "name": "gds.degree.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Degree centrality measures the number of incoming and outgoing relationships from a node."
  },
  {
    "function": {
      "name": "gds.degree.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Degree centrality measures the number of incoming and outgoing relationships from a node."
  },
  {
    "function": {
      "name": "gds.degree.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Degree centrality measures the number of incoming and outgoing relationships from a node."
  },
  {
    "function": {
      "name": "gds.degree.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Degree centrality measures the number of incoming and outgoing relationships from a node."
  },
  {
    "function": {
      "name": "gds.dfs.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures.\nThe algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph)\nand explores as far as possible along each branch before backtracking."
  },
  {
    "function": {
      "name": "gds.dfs.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.dfs.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures.\nThe algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph)\nand explores as far as possible along each branch before backtracking."
  },
  {
    "function": {
      "name": "gds.dfs.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures.\nThe algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph)\nand explores as far as possible along each branch before backtracking."
  },
  {
    "function": {
      "name": "gds.eigenvector.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Eigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes."
  },
  {
    "function": {
      "name": "gds.eigenvector.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.eigenvector.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Eigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes."
  },
  {
    "function": {
      "name": "gds.eigenvector.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.eigenvector.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Eigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes."
  },
  {
    "function": {
      "name": "gds.eigenvector.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.eigenvector.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Eigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes."
  },
  {
    "function": {
      "name": "gds.eigenvector.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.graph.sample.cnarw",
      "signature": "graph_name: str, from_G: Graph, **config: Any",
      "return_type": "GraphCreateResult"
    },
    "description": "Constructs a random subgraph based on common-neighbour-aware random walks."
  },
  {
    "function": {
      "name": "gds.graph.sample.cnarw.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.graph.sample.rwr",
      "signature": "graph_name: str, from_G: Graph, **config: Any",
      "return_type": "GraphCreateResult"
    },
    "description": "Constructs a random subgraph based on random walks with restarts."
  },
  {
    "function": {
      "name": "gds.hdbscan.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Hierarchical Density-Based Spatial Clustering of Applications with Noise"
  },
  {
    "function": {
      "name": "gds.hdbscan.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.hdbscan.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Hierarchical Density-Based Spatial Clustering of Applications with Noise"
  },
  {
    "function": {
      "name": "gds.hdbscan.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.hdbscan.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Hierarchical Density-Based Spatial Clustering of Applications with Noise"
  },
  {
    "function": {
      "name": "gds.hdbscan.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.hdbscan.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Hierarchical Density-Based Spatial Clustering of Applications with Noise"
  },
  {
    "function": {
      "name": "gds.hdbscan.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.hits.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes."
  },
  {
    "function": {
      "name": "gds.hits.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.hits.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes."
  },
  {
    "function": {
      "name": "gds.hits.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.hits.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes."
  },
  {
    "function": {
      "name": "gds.hits.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.hits.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes."
  },
  {
    "function": {
      "name": "gds.hits.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.influenceMaximization.celf.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes\nthat maximize the expected spread of influence in the network."
  },
  {
    "function": {
      "name": "gds.influenceMaximization.celf.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.influenceMaximization.celf.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Executes the algorithm and returns result statistics without writing the result to Neo4j."
  },
  {
    "function": {
      "name": "gds.influenceMaximization.celf.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.influenceMaximization.celf.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes\nthat maximize the expected spread of influence in the network."
  },
  {
    "function": {
      "name": "gds.influenceMaximization.celf.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes\nthat maximize the expected spread of influence in the network."
  },
  {
    "function": {
      "name": "gds.influenceMaximization.celf.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes\nthat maximize the expected spread of influence in the network."
  },
  {
    "function": {
      "name": "gds.influenceMaximization.celf.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.kmeans.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Kmeans  algorithm clusters nodes into different communities based on Euclidean distance"
  },
  {
    "function": {
      "name": "gds.kmeans.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.kmeans.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Kmeans  algorithm clusters nodes into different communities based on Euclidean distance"
  },
  {
    "function": {
      "name": "gds.kmeans.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.kmeans.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The Kmeans  algorithm clusters nodes into different communities based on Euclidean distance"
  },
  {
    "function": {
      "name": "gds.kmeans.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.kmeans.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Kmeans  algorithm clusters nodes into different communities based on Euclidean distance"
  },
  {
    "function": {
      "name": "gds.kmeans.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.k1coloring.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The K-1 Coloring algorithm assigns a color to every node in the graph."
  },
  {
    "function": {
      "name": "gds.k1coloring.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.k1coloring.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The K-1 Coloring algorithm assigns a color to every node in the graph."
  },
  {
    "function": {
      "name": "gds.k1coloring.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.k1coloring.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The K-1 Coloring algorithm assigns a color to every node in the graph."
  },
  {
    "function": {
      "name": "gds.k1coloring.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.k1coloring.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The K-1 Coloring algorithm assigns a color to every node in the graph."
  },
  {
    "function": {
      "name": "gds.k1coloring.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.kcore.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Computes the k-core values in a network"
  },
  {
    "function": {
      "name": "gds.kcore.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.kcore.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Computes the k-core values in a network"
  },
  {
    "function": {
      "name": "gds.kcore.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.kcore.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Computes the k-core values in a network"
  },
  {
    "function": {
      "name": "gds.kcore.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.kcore.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Computes the k-core values in a network"
  },
  {
    "function": {
      "name": "gds.kcore.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.knn.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties"
  },
  {
    "function": {
      "name": "gds.knn.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.knn.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties"
  },
  {
    "function": {
      "name": "gds.knn.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.knn.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties"
  },
  {
    "function": {
      "name": "gds.knn.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.knn.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties"
  },
  {
    "function": {
      "name": "gds.knn.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.knn.filtered.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties.\nFiltered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively.\n\n.. py:function:: gds.knn.filtered.mutate.estimate(G: Graph, **config: Any) -> Series[Any]\n\nReturns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.knn.filtered.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties.\nFiltered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively."
  },
  {
    "function": {
      "name": "gds.knn.filtered.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.knn.filtered.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties.\nFiltered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively."
  },
  {
    "function": {
      "name": "gds.knn.filtered.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.knn.filtered.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties.\nFiltered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively."
  },
  {
    "function": {
      "name": "gds.knn.filtered.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.kSpanningTree.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The K-spanning tree algorithm starts from a root node and returns a spanning tree with exactly k nodes"
  },
  {
    "function": {
      "name": "gds.labelPropagation.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Label Propagation algorithm is a fast algorithm for finding communities in a graph."
  },
  {
    "function": {
      "name": "gds.labelPropagation.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.labelPropagation.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Label Propagation algorithm is a fast algorithm for finding communities in a graph."
  },
  {
    "function": {
      "name": "gds.labelPropagation.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.labelPropagation.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The Label Propagation algorithm is a fast algorithm for finding communities in a graph."
  },
  {
    "function": {
      "name": "gds.labelPropagation.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.labelPropagation.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Label Propagation algorithm is a fast algorithm for finding communities in a graph."
  },
  {
    "function": {
      "name": "gds.labelPropagation.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.leiden.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Leiden is a community detection algorithm, which guarantees that communities are well connected"
  },
  {
    "function": {
      "name": "gds.leiden.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.leiden.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Executes the algorithm and returns result statistics without writing the result to Neo4j."
  },
  {
    "function": {
      "name": "gds.leiden.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.leiden.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Leiden is a community detection algorithm, which guarantees that communities are well connected"
  },
  {
    "function": {
      "name": "gds.leiden.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.leiden.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Leiden is a community detection algorithm, which guarantees that communities are well connected"
  },
  {
    "function": {
      "name": "gds.leiden.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.localClusteringCoefficient.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The local clustering coefficient is a metric quantifying how connected the neighborhood of a node is."
  },
  {
    "function": {
      "name": "gds.localClusteringCoefficient.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.localClusteringCoefficient.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Executes the algorithm and returns result statistics without writing the result to Neo4j."
  },
  {
    "function": {
      "name": "gds.localClusteringCoefficient.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.localClusteringCoefficient.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The local clustering coefficient is a metric quantifying how connected the neighborhood of a node is."
  },
  {
    "function": {
      "name": "gds.localClusteringCoefficient.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.localClusteringCoefficient.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The local clustering coefficient is a metric quantifying how connected the neighborhood of a node is."
  },
  {
    "function": {
      "name": "gds.localClusteringCoefficient.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.louvain.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Louvain method for community detection is an algorithm for detecting communities in networks."
  },
  {
    "function": {
      "name": "gds.louvain.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.louvain.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Executes the algorithm and returns result statistics without writing the result to Neo4j."
  },
  {
    "function": {
      "name": "gds.louvain.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.louvain.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The Louvain method for community detection is an algorithm for detecting communities in networks."
  },
  {
    "function": {
      "name": "gds.louvain.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.louvain.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Louvain method for community detection is an algorithm for detecting communities in networks."
  },
  {
    "function": {
      "name": "gds.louvain.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.maxkcut.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Approximate Maximum k-cut maps each node into one of k disjoint communities\ntrying to maximize the sum of weights of relationships between these communities."
  },
  {
    "function": {
      "name": "gds.maxkcut.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Approximate Maximum k-cut maps each node into one of k disjoint communities\ntrying to maximize the sum of weights of relationships between these communities."
  },
  {
    "function": {
      "name": "gds.maxkcut.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Approximate Maximum k-cut maps each node into one of k disjoint communities\ntrying to maximize the sum of weights of relationships between these communities."
  },
  {
    "function": {
      "name": "gds.maxkcut.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Approximate Maximum k-cut maps each node into one of k disjoint communities\ntrying to maximize the sum of weights of relationships between these communities."
  },
  {
    "function": {
      "name": "gds.modularity.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    }
  },
  {
    "function": {
      "name": "gds.modularity.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    }
  },
  {
    "function": {
      "name": "gds.modularity.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    }
  },
  {
    "function": {
      "name": "gds.modularity.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    }
  },
  {
    "function": {
      "name": "gds.modularityOptimization.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity."
  },
  {
    "function": {
      "name": "gds.modularityOptimization.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.modularityOptimization.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity."
  },
  {
    "function": {
      "name": "gds.modularityOptimization.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.modularityOptimization.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity."
  },
  {
    "function": {
      "name": "gds.modularityOptimization.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.modularityOptimization.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity."
  },
  {
    "function": {
      "name": "gds.modularityOptimization.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nNode Similarity computes pair-wise similarities based on the Jaccard metric."
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nNode Similarity computes pair-wise similarities based on the Jaccard metric."
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nNode Similarity computes pair-wise similarities based on the Jaccard metric."
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nNode Similarity computes pair-wise similarities based on the Jaccard metric."
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.filtered.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nThe algorithm computes pair-wise similarities based on Jaccard or Overlap metrics.\nThe filtered variant supports limiting which nodes to compare via source and target node filters."
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.filtered.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.filtered.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nThe algorithm computes pair-wise similarities based on Jaccard or Overlap metrics.\nThe filtered variant supports limiting which nodes to compare via source and target node filters."
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.filtered.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.filtered.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nThe algorithm computes pair-wise similarities based on Jaccard or Overlap metrics.\nThe filtered variant supports limiting which nodes to compare via source and target node filters."
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.filtered.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.filtered.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nThe algorithm computes pair-wise similarities based on Jaccard or Overlap metrics.\nThe filtered variant supports limiting which nodes to compare via source and target node filters."
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.filtered.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.pageRank.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Page Rank is an algorithm that measures the transitive influence or connectivity of nodes."
  },
  {
    "function": {
      "name": "gds.pageRank.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.pageRank.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Executes the algorithm and returns result statistics without writing the result to Neo4j."
  },
  {
    "function": {
      "name": "gds.pageRank.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.pageRank.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Page Rank is an algorithm that measures the transitive influence or connectivity of nodes."
  },
  {
    "function": {
      "name": "gds.pageRank.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.pageRank.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Page Rank is an algorithm that measures the transitive influence or connectivity of nodes."
  },
  {
    "function": {
      "name": "gds.pageRank.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.prizeSteinerTree.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "An approximation algorithm for the prize collector steiner tree problem"
  },
  {
    "function": {
      "name": "gds.prizeSteinerTree.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.prizeSteinerTree.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "An approximation algorithm for the prize collector steiner tree problem"
  },
  {
    "function": {
      "name": "gds.prizeSteinerTree.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.prizeSteinerTree.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "An approximation algorithm for the prize collector steiner tree problem"
  },
  {
    "function": {
      "name": "gds.prizeSteinerTree.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.prizeSteinerTree.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "An approximation algorithm for the prize collector steiner tree problem"
  },
  {
    "function": {
      "name": "gds.prizeSteinerTree.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.randomWalk.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Random Walk is an algorithm that provides random paths in a graph. It\u2019s similar to how a drunk person traverses a city. The mutate procedure produces the count a node occurs on a random walk."
  },
  {
    "function": {
      "name": "gds.randomWalk.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.randomWalk.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Random Walk is an algorithm that provides random paths in a graph. It\u2019s similar to how a drunk person traverses a city."
  },
  {
    "function": {
      "name": "gds.randomWalk.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.randomWalk.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Random Walk is an algorithm that provides random paths in a graph. It\u2019s similar to how a drunk person traverses a city."
  },
  {
    "function": {
      "name": "gds.randomWalk.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.shortestPath.astar.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The A* shortest path algorithm computes the shortest path between a pair of nodes. It uses the relationship weight\nproperty to compare path lengths. In addition,\nthis implementation uses the haversine distance as a heuristic to converge faster."
  },
  {
    "function": {
      "name": "gds.shortestPath.astar.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.shortestPath.astar.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The A* shortest path algorithm computes the shortest path between a pair of nodes. It uses the relationship weight\nproperty to compare path lengths. In addition,\nthis implementation uses the haversine distance as a heuristic to converge faster."
  },
  {
    "function": {
      "name": "gds.shortestPath.astar.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.shortestPath.astar.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The A* shortest path algorithm computes the shortest path between a pair of nodes. It uses the relationship weight\nproperty to compare path lengths. In addition,\nthis implementation uses the haversine distance as a heuristic to converge faster."
  },
  {
    "function": {
      "name": "gds.shortestPath.astar.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.shortestPath.dijkstra.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Dijkstra shortest path algorithm computes the shortest (weighted) path between a pair of nodes."
  },
  {
    "function": {
      "name": "gds.shortestPath.dijkstra.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.shortestPath.dijkstra.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The Dijkstra shortest path algorithm computes the shortest (weighted) path between a pair of nodes."
  },
  {
    "function": {
      "name": "gds.shortestPath.dijkstra.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.shortestPath.dijkstra.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Dijkstra shortest path algorithm computes the shortest (weighted) path between a pair of nodes."
  },
  {
    "function": {
      "name": "gds.shortestPath.dijkstra.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.shortestPath.yens.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Yen's shortest path algorithm computes the k shortest (weighted) paths between a pair of nodes."
  },
  {
    "function": {
      "name": "gds.shortestPath.yens.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.shortestPath.yens.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The Yen's shortest path algorithm computes the k shortest (weighted) paths between a pair of nodes."
  },
  {
    "function": {
      "name": "gds.shortestPath.yens.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.shortestPath.yens.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Yen's shortest path algorithm computes the k shortest (weighted) paths between a pair of nodes."
  },
  {
    "function": {
      "name": "gds.shortestPath.yens.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.sllpa.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph."
  },
  {
    "function": {
      "name": "gds.sllpa.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.sllpa.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph."
  },
  {
    "function": {
      "name": "gds.sllpa.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.sllpa.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph."
  },
  {
    "function": {
      "name": "gds.sllpa.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.sllpa.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph."
  },
  {
    "function": {
      "name": "gds.sllpa.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.spanningTree.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The spanning tree algorithm visits all nodes that are in the same connected component as the starting node,\nand returns a spanning tree of all nodes in the component where the total weight of the relationships is either minimized or maximized."
  },
  {
    "function": {
      "name": "gds.spanningTree.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.spanningTree.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The spanning tree algorithm visits all nodes that are in the same connected component as the starting node,\nand returns a spanning tree of all nodes in the component\nwhere the total weight of the relationships is either minimized or maximized."
  },
  {
    "function": {
      "name": "gds.spanningTree.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.spanningTree.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The spanning tree algorithm visits all nodes that are in the same connected component as the starting node,\nand returns a spanning tree of all nodes in the component\nwhere the total weight of the relationships is either minimized or maximized."
  },
  {
    "function": {
      "name": "gds.spanningTree.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.spanningTree.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The spanning tree algorithm visits all nodes that are in the same connected component as the starting node,\nand returns a spanning tree of all nodes in the component\nwhere the total weight of the relationships is either minimized or maximized."
  },
  {
    "function": {
      "name": "gds.spanningTree.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.steinerTree.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The steiner tree algorithm accepts a source node, as well as a list of target nodes.\nIt then attempts to find a spanning tree where there is a path from the source node to each target node,\nsuch that the total weight of the relationships is as low as possible."
  },
  {
    "function": {
      "name": "gds.steinerTree.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.steinerTree.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The steiner tree algorithm accepts a source node, as well as a list of target nodes.\nIt then attempts to find a spanning tree where there is a path from the source node to each target node,\nsuch that the total weight of the relationships is as low as possible."
  },
  {
    "function": {
      "name": "gds.steinerTree.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.steinerTree.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The steiner tree algorithm accepts a source node, as well as a list of target nodes.\nIt then attempts to find a spanning tree where there is a path from the source node to each target node,\nsuch that the total weight of the relationships is as low as possible."
  },
  {
    "function": {
      "name": "gds.steinerTree.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.steinerTree.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The steiner tree algorithm accepts a source node, as well as a list of target nodes.\nIt then attempts to find a spanning tree where there is a path from the source node to each target node,\nsuch that the total weight of the relationships is as low as possible."
  },
  {
    "function": {
      "name": "gds.steinerTree.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.triangleCount.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Triangle counting is a community detection graph algorithm that is used to\ndetermine the number of triangles passing through each node in the graph."
  },
  {
    "function": {
      "name": "gds.triangleCount.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.triangleCount.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Triangle counting is a community detection graph algorithm that is used to\ndetermine the number of triangles passing through each node in the graph."
  },
  {
    "function": {
      "name": "gds.triangleCount.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.triangleCount.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Triangle counting is a community detection graph algorithm that is used to\ndetermine the number of triangles passing through each node in the graph."
  },
  {
    "function": {
      "name": "gds.triangleCount.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.triangleCount.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Triangle counting is a community detection graph algorithm that is used to\ndetermine the number of triangles passing through each node in the graph."
  },
  {
    "function": {
      "name": "gds.triangleCount.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Triangle counting is a community detection graph algorithm that is used to\ndetermine the number of triangles passing through each node in the graph."
  },
  {
    "function": {
      "name": "gds.triangles",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "Triangles streams the nodeIds of each triangle in the graph."
  },
  {
    "function": {
      "name": "gds.wcc.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The WCC algorithm finds sets of connected nodes in an undirected graph,\nwhere all nodes in the same set form a connected component."
  },
  {
    "function": {
      "name": "gds.wcc.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.wcc.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Executes the algorithm and returns result statistics without writing the result to Neo4j."
  },
  {
    "function": {
      "name": "gds.wcc.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.wcc.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "The WCC algorithm finds sets of connected nodes in an undirected graph,\nwhere all nodes in the same set form a connected component."
  },
  {
    "function": {
      "name": "gds.wcc.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.wcc.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "The WCC algorithm finds sets of connected nodes in an undirected graph,\nwhere all nodes in the same set form a connected component."
  },
  {
    "function": {
      "name": "gds.wcc.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "Returns an estimation of the memory consumption for that procedure."
  },
  {
    "function": {
      "name": "gds.alpha.linkprediction.adamicAdar",
      "signature": "node1: int, node2: int, **config: Any",
      "return_type": "float"
    },
    "description": "Given two nodes, calculate Adamic Adar similarity"
  },
  {
    "function": {
      "name": "gds.alpha.linkprediction.commonNeighbors",
      "signature": "node1: int, node2: int, **config: Any",
      "return_type": "float"
    },
    "description": "Given two nodes, returns the number of common neighbors"
  },
  {
    "function": {
      "name": "gds.alpha.linkprediction.preferentialAttachment",
      "signature": "node1: int, node2: int, **config: Any",
      "return_type": "float"
    },
    "description": "Given two nodes, calculate Preferential Attachment"
  },
  {
    "function": {
      "name": "gds.alpha.linkprediction.resourceAllocation",
      "signature": "node1: int, node2: int, **config: Any",
      "return_type": "float"
    },
    "description": "Given two nodes, calculate Resource Allocation similarity"
  },
  {
    "function": {
      "name": "gds.alpha.linkprediction.sameCommunity",
      "signature": "node1: int, node2: int, communityProperty: Optional[str] = None",
      "return_type": "float"
    },
    "description": "Given two nodes, indicates if they have the same community"
  },
  {
    "function": {
      "name": "gds.alpha.linkprediction.totalNeighbors",
      "signature": "node1: int, node2: int, **config: Any",
      "return_type": "float"
    },
    "description": "Given two nodes, calculate Total Neighbors"
  }
]
