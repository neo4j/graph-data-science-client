= Aura Graph Analytics Serverless

:page-aliases: gds-session

Aura Graph Analytics Serverless is an on-demand ephemeral compute environment for running GDS workloads.
Each compute unit is called a _GDS Session_.
It is offered as part of link:https://neo4j.com/docs/aura/graph-analytics/[Neo4j Aura], a fast, scalable, always-on, fully automated cloud graph platform.

NOTE: Aura Graph Analytics Serverless is not available by default.
See the Aura https://neo4j.com/docs/aura/graph-analytics/#aura-gds-serverless[docs] for details on how to enable it.

A GDS Session is in one of three flavours, determined by its data source:

* *Attached*, sourced from a Neo4j AuraDB instance.
* *Self-managed*, sourced from a self-managed Neo4j DBMS.
* *Standalone*, sourced from a non-Neo4j data source.


We call the process of populating the session with data a _remote projection_.
Once populated, a GDS Session can run GDS workloads, such as algorithms and machine learning models.
Results from these computations can be written back to the original source, using _remote write-back_ in the Attached and Self-managed flavours.

TIP: For ready-to-run notebooks, see our tutorials on GDS Sessions for xref:tutorials/graph-analytics-serverless.adoc[AuraDB] and xref:tutorials/graph-analytics-serverless-self-managed[self-managed databases].


== GDS Session management

The `GdsSessions` object is the API entry point to the following operations:

- `get_or_create`: Create a new GDS Session, or connect to an existing one.
- `list`: List all currently active GDS Sessions.
- `delete`: Delete a GDS Session.


You need Neo4j Aura API credentials (`CLIENT_ID` and `CLIENT_SECRET`) to create a `GdsSessions` object.
See the link:{neo4j-docs-base-uri}/aura/platform/api/authentication/#_creating_credentials[Aura documentation] for instructions on how to create API credentials from your Neo4j Aura account.
If your Aura user is part of multiple projects, the desired project ID must also be provided.

.Creating a GdsSessions object:
[source, python, role=no-test]
----
from graphdatascience.session import GdsSessions, AuraAPICredentials

CLIENT_ID = "my-aura-api-client-id"
CLIENT_SECRET = "my-aura-api-client-secret"
PROJECT_ID = None

# Create a new GdsSessions object
sessions = GdsSessions(api_credentials=AuraAPICredentials(CLIENT_ID, CLIENT_SECRET, PROJECT_ID))
----

All available methods and parameters are listed in our API https://neo4j.com/docs/graph-data-science-client/{docs-version}/api/sessions/gds_sessions/[reference].


=== Creating a GDS Session

To create a GDS Session, use the `get_or_create()` method.
It will create a new session if it does not exist, or connect to an existing one if it does.
If the session options differ from the existing one, an error is thrown.

The return value of `get_or_create()` is an `AuraGraphDataScience` object.
It offers a similar API to the `GraphDataScience` object, but it is configured to run on a GDS Session.
As a convention, always use the variable name `gds` for the return value of `get_or_create()`.


==== Session expiration and deletion

When the session is created, an optional `ttl` parameter can be configured, which specifies how quickly an inactive session will expire.
The default value for `ttl` is 1 hour and the maximum allowed value is 7 days.
An expired session cannot be used to run workloads, does not cost anything, and will be deleted automatically after 7 days.
It can also be deleted through the Aura Console UI.


===== Maximum lifetime

A session can never be kept active for more than 7 days.
Even if the session does not expire due to inactivity, it will still expire 7 days after its creation.
This is a hard limit and cannot be changed.


==== Syntax

[source, role=no-test]
----
sessions.get_or_create(
    session_name: str,
    memory: SessionMemory,
    db_connection: Optional[DbmsConnectionInfo] = None,
    ttl: Optional[timedelta] = None,
    cloud_location: Optional[CloudLocation] = None,
    timeout: Optional[int] = None,
): AuraGraphDataScience
----

.Parameters:
[opts="header",cols="3m,1m,1,1m,6", role="no-break"]
|===
| Name          | Type               | Optional | Default | Description
| session_name  | str                | no       | -       | Name of the session. Must be unique within the project.
| memory        | SessionMemory      | no       | -       | Amount of memory available to the session. https://neo4j.com/docs/graph-data-science-client/{docs-version}/api/sessions/session_memory[Supported values].
| db_connection | DbmsConnectionInfo | yes      | None    | Bolt server URL, username, and password to a Neo4j DBMS. Required for the Attached and Self-managed flavours.
| ttl           | datetime.timedelta | yes      | 1h      | Time-to-live for the session.
| cloud_location| CloudLocation      | yes      | None    | Aura-supported cloud provider and region where the GDS Session will run. Required for the Self-managed and Standalone flavours.
| timeout       | int                | yes      | None    | Seconds to wait for the session to enter Ready state. If the time is exceeded, an error will be returned.
|===


==== Examples

[.tabbed-example, caption = ]
=====

[.include-with-attached]
=======

.Creating a GDS Session attached to an AuraDB instance:
[source,python,role=no-test]
----
from graphdatascience.session import DbmsConnectionInfo, SessionMemory

gds = sessions.get_or_create(
    session_name="my-attached-session",
    memory=SessionMemory.m_4GB,
    db_connection=DbmsConnectionInfo(
        "neo4j+s://mydbid.databases.neo4j.io",
        "my-user",
        "my-password"
    ),
)
----
=======

[.include-with-self-managed]
=======
.Creating a GDS Session for a self-managed Neo4j DBMS:
[source,python,role=no-test]
----
from graphdatascience.session import DbmsConnectionInfo, CloudLocation, SessionMemory

gds = sessions.get_or_create(
    session_name="my-self-managed-session",
    memory=SessionMemory.m_4GB,
    db_connection=DbmsConnectionInfo("neo4j://localhost", "my-user", "my-password"),
    cloud_location=CloudLocation(provider="gcp", region="europe-west1"),
)
----
=======

[.include-with-standalone]
=======
.Creating a GDS Session without any Neo4j database:
[source,python,role=no-test]
----
from graphdatascience.session import CloudLocation, SessionMemory

gds = sessions.get_or_create(
    session_name="my-standalone-session",
    memory=SessionMemory.m_4GB,
    cloud_location=CloudLocation(provider="gcp", region="europe-west1"),
)
----
=======

=====


=== Listing GDS Sessions

The `list()` method returns the name and size of memory of all currently active GDS Sessions.

.Listing GDS Sessions:
[source, python, role=no-test]
----
sessions.list()
----


=== Deleting a GDS Session

Deleting a GDS Session will terminate the session and stop any running costs from accumulating further.
Deleting a session will not affect the configured Neo4j data source.
However, any data not written back to the Neo4j instance will be lost.

If you have an open connection to the session:

.Deleting a GDS Session via an open client connection:
[source, python, role=no-test]
----
gds.delete()
----

Use the `delete()` method to delete a GDS Session.

.Deleting a GDS Session via the GdsSessions object:
[source, python, role=no-test]
----
sessions.delete(session_name="my-new-session")
----


=== Estimating session memory

In order to help determine a good session size for a given workload, there is the `estimate()` function.
By providing expected node and relationship counts as well as algorithm categories that should be used, it will return an estimated size of the session.

.Estimating the size of a GDS Session via the GdsSessions object:
[source, python, role=no-test]
----
from graphdatascience.session import AlgorithmCategory

memory = sessions.estimate(
    node_count=20,
    relationship_count=50,
    algorithm_categories=[AlgorithmCategory.CENTRALITY, AlgorithmCategory.NODE_EMBEDDING],
)
----


== Projecting graphs into a GDS Session

Once you have a GDS Session, you can project a graph into it.
This operation is called _remote projection_ because the data source is not a co-located database, but rather a remote one.

You can create a remote projection using the `gds.graph.project()` endpoint with a graph name, a Cypher query, and additional optional parameters.
The Cypher query must contain the `gds.graph.project.remote()` function to project the graph into the GDS Session.

=== Syntax

.Remote projection:
[source, role=no-test]
----
gds.graph.project(
    graph_name: str,
    query: str,
    concurrency: int = 4,
    undirected_relationship_types: Optional[List[str]] = None,
    inverse_indexed_relationship_types: Optional[List[str]] = None,
): (Graph, Series[Any])
----

.Parameters:
[opts="header",cols="3m,1,1m,6", role="no-break"]
|===
| Name                               | Optional | Default | Description
| graph_name                         | no       | -       | Name of the graph.
| query                              | no       | -       | Projection query.
| concurrency                        | yes      | 4       | Concurrency to use for building the graph within the session.
| batch_size                         | yes      | 10000   | Size of batches transmitted from the DBMS to the session.
| undirected_relationship_types      | yes      | []      | List of relationship type names that should be treated as undirected.
| inverse_indexed_relationship_types | yes      | []      | List of relationship type names that should be indexed in reverse.
|===

.Results:
[opts="header",cols="1m,1m,4", role="no-break"]
|===
| Name   | Type        | Description
| graph  | Graph       | Graph object representing the projected graph.
| result | Series[Any] | Statistical data about the projection.
|===

The `concurrency` and `batch_size` configuration parameters can be used to tune the performance of the remote projection.

[NOTE]
The concurrency of the remote projection query is controlled by the Cypher runtime on the DBMS server.
Use `CYPHER runtime=parallel` as a query prefix to maximise performance.
The actual concurrency used depends on the DBMS server's available processors and current operational load.


==== Remote projection query syntax

The remote projection query supports the same syntax as a Cypher projection, with two key differences:

. The graph name is not a parameter.
Instead, the graph name is provided to the `gds.graph.project()` endpoint.
. The `gds.graph.project.remote()` function must be used, instead of the `gds.graph.project()` function.

For full details and examples on how to write Cypher projection queries, see the https://neo4j.com/docs/graph-data-science/current/management-ops/graph-creation/graph-project-cypher-projection/[Cypher projection documentation in the GDS Manual].


==== Relationship type undirectedness and inverse indexing

The optional parameters `undirectedRelationshipTypes` and `inverseIndexedRelationshipTypes` are used to configure undirectedness and inverse indexing of relationships.
These have the same behavior as documented in the link:{neo4j-docs-base-uri}/graph-data-science/current/management-ops/graph-creation/graph-project-cypher-projection/#graph-project-cypher-projection-syntax[GDS Manual].


=== Example

This example shows how to project a graph into a GDS Session.
The example graph is heterogeneous and models users and products.
Users can know each other, and users can buy products.
The database connection is to a new, empty AuraDB instance.

.Create a GDS Session and add some data to the database:
[source,python,role=no-test]
----
import os # for reading environment variables
from graphdatascience.session import SessionMemory, DbmsConnectionInfo, GdsSessions, AuraAPICredentials

sessions = GdsSessions(api_credentials=AuraAPICredentials(os.environ["CLIENT_ID"], os.environ["CLIENT_SECRET"]))

db_connection = DbmsConnectionInfo(os.environ["DB_URI"], os.environ["DB_USER"], os.environ["DB_PASSWORD"])
gds = sessions.get_or_create(
    session_name="my-new-session",
    memory=SessionMemory.m_8GB,
    db_connection=db_connection,
)

gds.run_cypher(
    """
    CREATE
     (u1:User {name: 'Mats'}),
     (u2:User {name: 'Florentin'}),
     (p1:Product {name: 'ice cream', cost: 4.2}),
     (p2:Product {name: 'computer', cost: 13.37})

    CREATE
     (u1)-[:KNOWS {since: 2020}]->(u2),
     (u2)-[:BOUGHT {price: 7474}]->(p1),
     (u1)-[:BOUGHT {price: 1337}]->(p2)
    """
)
----

With the `gds` GDS Session active, project the graph and specify node and relationship property schemas as follows:

.Project a graph into the GDS Session:
[source,python,role=no-test]
----
G, result = gds.graph.project(
    graph_name="my-graph",
    query="""
    CALL {
        MATCH (u1:User)
        OPTIONAL MATCH (u1)-[r:KNOWS]->(u2:User)
        RETURN u1 AS source, r AS rel, u2 AS target, {} AS sourceNodeProperties, {} AS targetNodeProperties
        UNION
        MATCH (p:Product)
        OPTIONAL MATCH (p)<-[r:BOUGHT]-(user:User)
        RETURN user AS source, r AS rel, p AS target, {} AS sourceNodeProperties, {cost: p.cost} AS targetNodeProperties
    }
    RETURN gds.graph.project.remote(source, target, {
      sourceNodeProperties: sourceNodeProperties,
      targetNodeProperties: targetNodeProperties,
      sourceNodeLabels: labels(source),
      targetNodeLabels: labels(target),
      relationshipType: type(rel),
      relationshipProperties: properties(rel)
    })
    """,
)
----


== Running algorithms

You can run algorithms on a remotely projected graph in the same way you would on any projected graph.
For instance, you can run the PageRank and FastRP algorithms on the projected graph from the previous example as follows:

.Run algorithms and stream back results:
[source,python,role=no-test]
----
gds.pageRank.mutate(G, mutateProperty="pr")
gds.fastRP.mutate(G, featureProperties=["pr"], embeddingDimension=2, nodeSelfInfluence=0.1, mutateProperty="embedding")

# Stream the results back together with the `name` property fetched from the database
gds.graph.nodeProperties.stream(G, db_node_properties=["name"], node_properties=["pr", "embedding"])
----

For a full list of the available algorithms, see the https://neo4j.com/docs/graph-data-science-client/{page-version}/api/[API reference].


=== Limitations

* Model Catalog is supported with limitations:
** Trained models can only be used for prediction using the same Session in which they were trained.
   After the Session is deleted, all trained models will be lost.
** Model publishing is not supported, including
*** `gds.model.publish`
** Model persistence is not supported, including
*** `gds.model.store`
*** `gds.model.load`
*** `gds.model.delete`
* Topological Link Prediction algorithms are not supported, including
** `gds.alpha.linkprediction.adamicAdar`
** `gds.alpha.linkprediction.commonNeighbors`
** `gds.alpha.linkprediction.preferentialAttachment`
** `gds.alpha.linkprediction.resourceAllocation`
** `gds.alpha.linkprediction.sameCommunity`
** `gds.alpha.linkprediction.totalNeighbors`


== Remote write-back

The GDS Session's in-memory graph was projected from data in AuraDB, so write-back operations will persist the data back to the same AuraDB instance.
When calling any write operations, the GDS Python client will automatically use the remote write-back functionality.
This includes all `.write` algorithm modes as well as all `.write` graph operations.

By default, write back will happen concurrently, in one transaction per batch.
The behaviour is controlled by three aspects:

- the size of the dataset (e.g., node count or relationship count)
- the configured batch size
- the configured concurrency


=== Syntax

[.tabbed-example, caption = asd]
====
[.include-with-graph-operation]
======
.Remote graph write-back:
[source, role=no-test]
----
gds.graph.<operation>.write(
    graph_name: str,
    # additional parameters,
    **config: Any,
): Series[Any]
----
======

[.include-with-algorithm-write-mode]
======
.Remote graph write-back:
[source, role=no-test]
----
gds.<algo>.write(
    graph_name: str,
    **config: Any,
): Series[Any]
----
======
====


All write-back endpoints support the following additional configuration:

.Parameters:
[opts="header",cols="1m,1,1,6", role="no-break"]
|===
| Name               | Optional | Default | Description
| concurrency        | yes      | dynamic footnote:[Twice the number of processors on the DBMS server] | Concurrency to use for writing back to the DBMS.
| arrowConfiguration | yes      | -       | Dict containing additional configuration for the connection from the DBMS to the GDS Arrow Server.
|===

.Arrow configuration:
[opts="header",cols="1m,1,1m,6", role="no-break"]
|===
| Name      | Optional | Default | Description
| batchSize | yes      | 10000   | Size of batches retrieved by the DBMS from the session.
|===


=== Examples

Extending the previous example, we can write back the FastRP embeddings to the AuraDB instance as follows:

.Write mutated FastRP embeddings back to the database:
[source,python,role=no-test]
----
gds.graph.nodeProperties.write(G, "embedding")
----

If we want to tune the performance of the write-back, we can configure `batchSize` and `concurrency`.
In this example we show how to do this with an algorithm `.write` mode:

.Compute WCC and write the component ids back as node properties, with custom concurrency configuration:
[source,python,role=no-test]
----
gds.wcc.write(
  G,
  writeProperty="wcc",
  concurrency=12,
  arrowConfiguration={"batchSize": 25000}
)
----


== Querying the database

You can run Cypher queries on the AuraDB instance using the `run_cypher()` method.
There is no restriction on the type of query that can be run, but it is important to note that the query will be run on the AuraDB instance, and not on the GDS Session.
Therefore, you will not be able to call any GDS procedures from the `run_cypher()` method.

.Run a Cypher query to find our written-back embeddings:
[source,python,role=no-test]
----
gds.run_cypher("MATCH (n:User) RETURN n.name, n.embedding")
----
