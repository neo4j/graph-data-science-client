= Quickstart

The design philosophy of the Python client is to mimic the GDS Cypher API in Python code.
The Python client will translate the Python code written by the user to a corresponding Cypher query which it will then run on the Neo4j server using a Neo4j Python driver connection.

The Python client attempts to be as pythonic as possible to maximize convenience for users accustomed to and experienced with Python environments.
As such standard Python and pandas types are used as much as possible.
However, to be consistent with the Cypher surface the general return value of calling a method corresponding to a Cypher procedure will be in the form of a table (a pandas `DataFrame` in Python).
Read more about this in xref:getting-started.adoc#getting-started-mapping[Mapping between Cypher and Python].

The root component of the Python client is the `GraphDataScience` object.
Once instantiated it forms the entrypoint to interacting with the GDS library.
That includes projecting graphs, running algorithms, and defining and using machine learning pipelines in GDS.
As a convention we recommend always calling the instantiated `GraphDataScience` object `gds` as using it will then most resemble using the Cypher API directly.


== Import and setup

Use the Neo4j URI and credentials according to your setup.

[.tabbed-example]
====
[.include-with-Neo4j-server]
=====
[source, python, role=no-test]
----
from graphdatascience import GraphDataScience

# For example, in a local setup `NEO4J_URI` would be "neo4j://127.0.0.1:7687".
gds = GraphDataScience(NEO4J_URI, auth=(NEO4J_USER, NEO4J_PASSWORD))
----

The `GraphDataScience` object needs the Neo4j database to be available upon construction, and uses the default `neo4j` database by default.
If the `neo4j` database does not exist or you want to use a different database, use the `database` keyword parameter:

[source, python, role=no-test]
----
gds = GraphDataScience(NEO4J_URI, auth=(NEO4J_USER, NEO4J_PASSWORD), database="my-db")
----

You can also change the database after creating the `GraphDataScience` object:

[source, python, role=no-test]
----
gds.set_database("my-db")
----
=====

[.include-with-Aura-Graph-Analytics]
=====
The Python client has dedicated support for link:{aura-docs-base-uri}/graph-analytics[Aura Graph Analytics].

This example shows how to instantiate the `GraphDataScience` object using an Aura API key pair and AuraDB connection information.

[source, python, role=no-test]
----
from graphdatascience.session import DbmsConnectionInfo, GdsSessions, AuraAPICredentials, SessionMemory

sessions = GdsSessions(api_credentials=AuraAPICredentials(AURA_API_CLIENT_ID, AURA_API_CLIENT_SECRET))

# `NEO4J_URI` has the format "neo4j+s://xxxxxxxx.databases.neo4j.io".
# The credentials are for the AuraDB instance.
gds = sessions.get_or_create(
    session_name="my-session",
    memory=SessionMemory.m_4GB,
    db_connection=DbmsConnectionInfo(NEO4J_URI, NEO4J_USER, NEO4J_PASSWORD),
)
----
=====

[.include-with-AuraDS]
=====
If you are connecting the client to an link:https://neo4j.com/cloud/graph-data-science/[AuraDS instance], you can get recommended non-default configuration settings of the Python driver applied automatically with `aura_ds=True`:

[source, python, role=no-test]
----
from graphdatascience import GraphDataScience

# Configures the driver with AuraDS-recommended settings.
# `NEO4J_URI` has the format "neo4j+s://xxxxxxxx.databases.neo4j.io:7687".
gds = GraphDataScience(
    NEO4J_URI,
    auth=(NEO4J_USER, NEO4J_PASSWORD),
    aura_ds=True
)
----
=====
====

=== Additional checks

Check the version of GDS library running on the server:

[source, python]
----
print(gds.server_version())
----

Check if the GDS library running on the server has an enterprise license:

[source, python]
----
print(gds.is_licensed())
----


[[getting-started-minimal-example]]
== Usage example

The following example shows how to use the `GraphDataScience` object to:

. Run a Cypher query to populate the Neo4j database.
. Create a graph projection.
. Run an algorithm on the graph.
. Inspect the updated graph.

[source, python]
----
# Create a minimal example graph.
# The method returns a Pandas `DataFrame`.
gds.run_cypher(
  """
  CREATE
  (m: City {name: "Malmö"}),
  (l: City {name: "London"}),
  (s: City {name: "San Mateo"}),
  (m)-[:FLY_TO]->(l),
  (l)-[:FLY_TO]->(m),
  (l)-[:FLY_TO]->(s),
  (s)-[:FLY_TO]->(l)
  """
)

# Create an in-memory graph called `neo4j-offices` and
# a `G_office` object representing the projected graph.
G_office, project_result = gds.graph.project("neo4j-offices", "City", "FLY_TO")

# Run the `mutate` mode of the PageRank algorithm.
mutate_result = gds.pageRank.mutate(G_office, tolerance=0.5, mutateProperty="rank")

# Inspect the node properties of the projected graph
# via the graph object to confirm that a new property has been created.
assert G_office.node_properties("City") == ["rank"]
----

NOTE: You can also use one of the datasets that comes with the library to get started.
See the xref:common-datasets.adoc[] chapter for more on this.


[NOTE]
====
The client library is designed so that most methods are inferred under the hood as you type them via a string building scheme and overloading the magic `\\__getattr__` method.
Therefore, most methods such as `pageRank` will not appear when calling `dir(gds)`.
Similarly, IDEs and language servers will not be able to detect these automatically inferred methods, meaning that the auto-completion support they provide will be limited.
Despite the lack of this type of discoverability, the inferred methods such as `gds.pageRank.stream` will still be called correctly.
====


== Close open connections

Similarly to how the Neo4j Python driver supports closing all open connections to the DBMS, you can call `close` on the `GraphDataScience` object to the same effect:

[source,python,role=no-test]
----
# Close any open connections in the underlying Neo4j driver's connection pool
gds.close()
----

The `close` method is also called automatically when the `GraphDataScience` object is deleted.
